<script>
const {SocketRequest} = require('@advanced-rest-client/electron-request');
/**
 * `electron-http-transport`
 *
 * A web comonent to work with @advanced-rest-client/electron-request
 * node package in web components environment
 *
 * @customElement
 * @memberof LogicElements
 */
class ElectronHttpTransport extends HTMLElement {
  static get is() {return 'electron-http-transport';}

  constructor() {
    super();
    // Socket handlers
    this._loadStartHandler = this._loadStartHandler.bind(this);
    this._firstByteHandler = this._firstByteHandler.bind(this);
    this._loadEndHandler = this._loadEndHandler.bind(this);
    this._beforeRedirectHandler = this._beforeRedirectHandler.bind(this);
    this._headersReceivedHandler = this._headersReceivedHandler.bind(this);
    this._loadHandler = this._loadHandler.bind(this);
    this._errorHandler = this._errorHandler.bind(this);
    // Host data handlers
    this._ruleUpdated = this._ruleUpdated.bind(this);
    this._ruleDeleted = this._ruleDeleted.bind(this);
    // Transport control
    this._onTransportRequested = this._onTransportRequested.bind(this);
    this._abortHandler = this._abortHandler.bind(this);
    // Local properties
    this._connections = {};
  }

  connectedCallback() {
    document.body.addEventListener('transport-request', this._onTransportRequested);
    document.body.addEventListener('abort-api-request', this._abortHandler);
    window.addEventListener('host-rules-changed', this._ruleUpdated);
    window.addEventListener('host-rules-deleted', this._ruleDeleted);
  }

  disconnectedCallback() {
    document.body.removeEventListener('transport-request', this._onTransportRequested);
    document.body.removeEventListener('abort-api-request', this._abortHandler);
    window.addEventListener('host-rules-changed', this._ruleUpdated);
    window.addEventListener('host-rules-deleted', this._ruleDeleted);
  }

  _abortHandler(e) {
    const id = e.detail.id;
    const info = this._connections[id];
    if (!info) {
      return;
    }
    e.preventDefault();
    info.connection.abort();
    info.aborted = true;
  }

  _onTransportRequested(e) {
    if (e.defaultPrevented) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();
    this.run(e.detail);
  }
  /**
   * Runs the request with Electron's `SocketRequest` class.
   * @param {Object} request ARC request object
   * @param {?Object} opts Additional request options:
   * - timeout {Number} - Timeout in milliseconds
   * - followRedirects {Boolean}
   * Note, as of ARC 13 this object is part of the request object under
   * `config` property.
   * @return {Promise} A promise when the request is started with the socket
   * library
   */
  run(request, opts) {
    if (!opts && request.config) {
      opts = request.config;
    }
    if (!opts) {
      opts = {};
    }
    return this._readTimeout(opts)
    .then((timeout) => {
      opts.timeout = timeout;
      return this._readHosts();
    })
    .then((hosts) => {
      opts.hosts = hosts;
      return this._prepareRequest(request, opts);
    })
    .then((connection) => this._makeConnection(connection));
  }
  /**
   * Reads request timeout settings.
   * If `timeout` is set on `opts` then it returns this timeout.
   * Then it reads global settings for the application and reads
   * `requestDefaultTimeout` property. By default it returns `0`.
   * @param {Object} opts Request options
   * @return {Promise<Number>} Time in milliseconds
   */
  _readTimeout(opts) {
    if (typeof opts.timeout === 'number') {
      return Promise.resolve(opts.timeout);
    }
    const e = new CustomEvent('settings-read', {
      bubbles: true,
      composed: true,
      cancelable: true,
      detail: {
        settings: ['requestDefaultTimeout']
      }
    });
    this.dispatchEvent(e);
    if (e.defaultPrevented) {
      return e.detail.result
      .then((settings) => {
        if (!settings) {
          settings = {};
        }
        if (!settings.requestDefaultTimeout) {
          return 0;
        }
        let time = Number(settings.requestDefaultTimeout);
        if (time !== time) {
          time = 0;
        }
        // This time is in seconds
        return time * 1000;
      });
    } else {
      return Promise.resolve(0);
    }
  }
  /**
   * Reads application hosts configuration and returns it.
   * It returns empty array of hosts couldn't be read.
   * @return {Promise<Array>}
   */
  _readHosts() {
    if (this.hosts !== undefined) {
      return Promise.resolve(this.hosts);
    }
    const e = new CustomEvent('host-rules-list', {
      bubbles: true,
      composed: true,
      cancelable: true,
      detail: {}
    });
    this.dispatchEvent(e);
    if (!e.defaultPrevented) {
      this.hosts = [];
      return Promise.resolve(this.hosts);
    }
    return e.detail.result
    .then((rules) => {
      this.hosts = rules || [];
      return rules;
    });
  }

  _prepareRequest(request, opts) {
    const conn = new SocketRequest(request, opts);
    this._connections[request.id] = {
      connection: conn,
      aborted: false
    };
    conn.on('loadstart', this._loadStartHandler);
    conn.on('firstbyte', this._firstByteHandler);
    conn.on('loadend', this._loadEndHandler);
    conn.on('beforeredirect', this._beforeRedirectHandler);
    conn.on('headersreceived', this._headersReceivedHandler);
    conn.on('load', this._loadHandler);
    conn.on('error', this._errorHandler);
    return conn;
  }

  _makeConnection(connection) {
    return connection.send()
    .catch((cause) => {
      this._errorHandler(connection.id, cause);
    });
  }

  _removeConnectionHandlers(connection) {
    connection.removeListener('loadstart', this._loadStartHandler);
    connection.removeListener('firstbyte', this._firstByteHandler);
    connection.removeListener('loadend', this._loadEndHandler);
    connection.removeListener('beforeredirect', this._beforeRedirectHandler);
    connection.removeListener('headersreceived', this._headersReceivedHandler);
    connection.removeListener('load', this._loadHandler);
    connection.removeListener('error', this._errorHandler);
  }

  _informStatus(type, id) {
    const info = this._connections[id];
    if (!info || info.aborted) {
      return;
    }
    this.dispatchEvent(new CustomEvent(type, {
      composed: true,
      bubbles: true,
      detail: {
        id
      }
    }));
  }

  _loadStartHandler(id) {
    this._informStatus('request-load-start', id);
  }

  _firstByteHandler(id) {
    this._informStatus('request-first-byte-received', id);
  }

  _loadEndHandler(id) {
    this._informStatus('request-load-end', id);
  }

  _beforeRedirectHandler(id, detail) {
    const info = this._connections[id];
    if (!info || info.aborted) {
      return;
    }
    const e = new CustomEvent('before-redirect', {
      composed: true,
      bubbles: true,
      cancelable: true,
      detail: {
        id,
        url: detail.location
      }
    });
    this.dispatchEvent(e);
    if (e.defaultPrevented) {
      detail.returnValue = false;
    }
  }

  _headersReceivedHandler(id, detail) {
    const info = this._connections[id];
    if (!info || info.aborted) {
      return;
    }
    const e = new CustomEvent('headers-received', {
      composed: true,
      bubbles: true,
      cancelable: true,
      detail: {
        id,
        value: detail.value
      }
    });
    this.dispatchEvent(e);
    if (e.defaultPrevented) {
      detail.returnValue = false;
    }
  }

  _loadHandler(id, response, request) {
    const info = this._connections[id];
    if (!info || info.aborted) {
      return;
    }
    this._removeConnectionHandlers(info.connection);
    delete this._connections[id];
    this._processResponse(id, response, request);
  }

  _errorHandler(id, cause, request, response) {
    const info = this._connections[id];
    if (info) {
      this._removeConnectionHandlers(info.connection);
      delete this._connections[id];
    }
    if (info && info.aborted) {
      return;
    }
    if (!response) {
      response = {};
    }
    let data = Object.assign({}, response, {
      isError: true,
      error: cause
    });
    this._processResponse(id, data, request);
  }
  /**
   * Processes response data and creates ARC response object.
   * @param {String} id Request ID
   * @param {Object} data Response data
   * @param {Object} requestInfo Request data
   */
  _processResponse(id, data, requestInfo) {
    const detail = {
      isXhr: false,
      request: requestInfo
    };
    const redirects = this._processRedirects(data.redirects);
    if (redirects.timings.length) {
      detail.redirectTimings = redirects.timings;
      detail.redirects = redirects.redirects;
    }
    if (data.error && typeof data.error !== 'function') {
      detail.isError = true;
      detail.error = data.error;
    } else {
      const stats = this._cleanTimings(data.stats);
      detail.isError = false;
      detail.response = data;
      detail.sentHttpMessage = data.sentHttpMessage;
      detail.loadingTime = this._computeLoadingTime(stats);
      detail.timings = stats;
      detail.auth = data.auth;
      delete detail.response.sentHttpMessage;
      delete detail.request.sentHttpMessage;
    }
    detail.id = id;
    this._beforeResponse(detail);
  }
  /**
   * Processes redirects data from the socket library.
   * @param {Set} set A set of redirects
   * @return {Object} Map of arrays of timings and redirects information.
   */
  _processRedirects(set) {
    const result = {
      timings: [],
      redirects: []
    };
    if (!set) {
      return result;
    }
    set.forEach((item) => {
      result.redirects.push(item);
      result.timings.push(item.stats);
      delete item.stats;
    });
    return result;
  }
  /**
   * Computes a request / response loading time from the stats object
   * @param {Objject} stats A stats property of the socket client response.
   * @return {Number} A time to full response in miliseconds. 0 if stats unavailable.
   */
  _computeLoadingTime(stats) {
    if (!stats) {
      return 0;
    }
    let value = 0;
    if (stats.dns && stats.dns > 0) {
      value += stats.dns;
    }
    if (stats.connect && stats.connect > 0) {
      value += stats.connect;
    }
    if (stats.receive && stats.receive > 0) {
      value += stats.receive;
    }
    if (stats.send && stats.send > 0) {
      value += stats.send;
    }
    if (stats.ssl && stats.ssl > 0) {
      value += stats.ssl;
    }
    if (stats.wait && stats.wait > 0) {
      value += stats.wait;
    }
    return value;
  }
  /**
   * Creates HAR 1.2 object from timing data
   * @param {Object} stats
   * @return {Object}
   */
  _cleanTimings(stats) {
    const result = {
      dns: stats.dns || -1,
      connect: stats.connect || -1,
      receive: stats.receive || -1,
      send: stats.send || -1,
      ssl: stats.ssl || -1,
      wait: stats.wait || -1
    };
    return result;
  }
  /**
   * Dispatches `response-ready` event with request data.
   * If the event is not caneled then it dispatches `report-response`
   * event.
   *
   * @param {Object} detail The request detail
   */
  _beforeResponse(detail) {
    const e = new CustomEvent('response-ready', {
      composed: true,
      bubbles: true,
      cancelable: true,
      detail
    });
    this.dispatchEvent(e);
    if (e.defaultPrevented) {
      return;
    }
    this._reportResponse(e.detail);
  }
  /**
   * Fires the `report-response` custom event with immutable response data.
   * @param {Object} detail The event detail object.
   */
  _reportResponse(detail) {
    detail = this._prepareTransportObject(detail);
    const e = new CustomEvent('report-response', {
      composed: true,
      bubbles: true,
      cancelable: false,
      detail
    });
    this.dispatchEvent(e);
  }
  /**
   * Creates an immutable `detail` object for the `report-response` custom
   * event.
   * @param {Object} detail
   * @return {Object} Immutable object.
   */
  _prepareTransportObject(detail) {
    const configuration = {};
    Object.keys(detail).forEach((key) => {
      configuration[key] = {
        value: detail[key],
        writable: false,
        enumerable: true
      };
    });
    return Object.create(Object.prototype, configuration);
  }
  /**
   * Updates a rule from the `host-rules-changed` custom event.
   * The event should contain `rule` property on the event's detail object
   * containing the rule object.
   * @param {CustomEvent} e
   */
  _ruleUpdated(e) {
    if (e.cancelable || !this.hosts) {
      // Don't update rules if there's no local hosts array. Let the component
      // ask for all rules first.
      return;
    }
    const updatedValue = e.detail.rule;
    const index = this.hosts.findIndex((item) => item._id === updatedValue._id);
    if (index === -1) {
      this.hosts.push(updatedValue);
    } else {
      this.hosts[index] = updatedValue;
    }
  }
  /**
   * Deletes the rule from the `host-rules-deleted` custom event.
   * The event should contain `rule` property on the event's detail object
   * containing the rule object.
   *
   * @param {CustomEvent} e
   */
  _ruleDeleted(e) {
    if (e.cancelable) {
      return;
    }
    if (!this.hosts || !this.hosts.length) {
      return;
    }
    const id = e.detail.id;
    const index = this.hosts.findIndex((item) => item._id === id);
    if (index === -1) {
      return;
    }
    this.hosts.splice(index, 1);
  }
}
window.customElements.define(ElectronHttpTransport.is, ElectronHttpTransport);
</script>
